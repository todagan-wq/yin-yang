<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YIN-YANG Axis System</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
        }
        
        .container {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-top: 0;
        }
        
        .info-panel {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 5px;
        }
        
        .coordinate {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        
        .selected-panel {
            margin-top: 20px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 5px;
            display: none;
        }
        
        .selected-panel.active {
            display: block;
        }
        
        .selected-info {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .control-group {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 10px;
        }
        
        .value-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .value-control label {
            font-weight: bold;
            min-width: 30px;
        }
        
        .value-control span {
            font-size: 16px;
            min-width: 40px;
            text-align: center;
        }
        
        .control-btn {
            padding: 5px 10px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .control-btn:hover {
            background: #1976d2;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            border: 1px solid #ddd;
            cursor: crosshair;
            background: white;
        }
        
        button {
            display: block;
            margin: 20px auto;
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #764ba2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Coordinate System: YIN & YANG</h1>
        <button onclick="randomizeElements()">Random</button>
        <canvas id="canvas" width="600" height="600"></canvas>
        <div class="selected-panel" id="selectedPanel">
            <div class="selected-info" id="selectedInfo"></div>
            <div class="control-group">
                <div class="value-control">
                    <label>YIN:</label>
                    <button class="control-btn" onclick="changeX(-1)">−</button>
                    <span id="xValue">0</span>
                    <button class="control-btn" onclick="changeX(1)">+</button>
                </div>
                <div class="value-control">
                    <label>YANG:</label>
                    <button class="control-btn" onclick="changeY(-1)">−</button>
                    <span id="yValue">0</span>
                    <button class="control-btn" onclick="changeY(1)">+</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Canvas settings
        const padding = 40;
        const scale = (canvas.width - 2 * padding) / 100; // pixels per unit (0-100)
        const originX = padding; // x = 0
        const originY = canvas.height - padding; // y = 0
        
        // Axes meet at (50, 50)
        const axisX = originX + 50 * scale; // x position of Y axis
        const axisY = originY - 50 * scale; // y position of X axis
        
        // Predefined 5 elements - arranged in circle around (50, 50) with radius 25
        const elements = [
            { name: 'Fire', color: '#d32f2f', x: 50, y: 75 },
            { name: 'Earth', color: '#ff9800', x: 74, y: 58 },
            { name: 'Metal', color: '#9e9e9e', x: 65, y: 30 },
            { name: 'Water', color: '#2196f3', x: 35, y: 30 },
            { name: 'Wood', color: '#4caf50', x: 26, y: 58 }
        ];
        
        // Store original positions for watermarks
        const originalPositions = elements.map(e => ({ x: e.x, y: e.y, color: e.color, name: e.name }));
        
        // Order for connecting lines
        const connectionOrder = [0, 1, 2, 3, 4, 0]; // fire -> earth -> metal -> water -> wood -> fire
        
        let selectedElement = null;
        
        // Draw the axis system
        function drawAxis() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 100; i += 10) {
                const xPos = originX + i * scale;
                const yPos = originY - i * scale;
                
                // Vertical grid lines
                ctx.beginPath();
                ctx.moveTo(xPos, padding);
                ctx.lineTo(xPos, canvas.height - padding);
                ctx.stroke();
                
                // Horizontal grid lines
                ctx.beginPath();
                ctx.moveTo(padding, yPos);
                ctx.lineTo(canvas.width - padding, yPos);
                ctx.stroke();
            }
            
            // X Axis (YIN) - horizontal line at y = 50
            ctx.strokeStyle = '#1976d2';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, axisY);
            ctx.lineTo(canvas.width - padding, axisY);
            ctx.stroke();
            
            // Y Axis (YANG) - vertical line at x = 50
            ctx.strokeStyle = '#d32f2f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(axisX, padding);
            ctx.lineTo(axisX, canvas.height - padding);
            ctx.stroke();
            
            // X Axis Arrow
            ctx.fillStyle = '#1976d2';
            ctx.beginPath();
            ctx.moveTo(canvas.width - padding, axisY);
            ctx.lineTo(canvas.width - padding - 15, axisY - 5);
            ctx.lineTo(canvas.width - padding - 15, axisY + 5);
            ctx.closePath();
            ctx.fill();
            
            // Y Axis Arrow
            ctx.fillStyle = '#d32f2f';
            ctx.beginPath();
            ctx.moveTo(axisX, padding);
            ctx.lineTo(axisX - 5, padding + 15);
            ctx.lineTo(axisX + 5, padding + 15);
            ctx.closePath();
            ctx.fill();
            
            // Axis Labels
            ctx.fillStyle = '#1976d2';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('YIN', canvas.width - 20, axisY + 25);
            
            ctx.fillStyle = '#d32f2f';
            ctx.textAlign = 'center';
            ctx.fillText('YANG', axisX - 15, padding - 5);
            
            // Tick marks and labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 100; i += 10) {
                const xPos = originX + i * scale;
                const yPos = originY - i * scale;
                
                // X axis ticks
                ctx.beginPath();
                ctx.moveTo(xPos, axisY - 3);
                ctx.lineTo(xPos, axisY + 3);
                ctx.stroke();
                
                // X axis labels - only 0 and 100
                if (i === 0 || i === 100) {
                    ctx.textAlign = 'center';
                    ctx.fillText(i, xPos, axisY + 15);
                }
                
                // Y axis ticks
                ctx.beginPath();
                ctx.moveTo(axisX - 3, yPos);
                ctx.lineTo(axisX + 3, yPos);
                ctx.stroke();
                
                // Y axis labels - only 0 and 100
                if (i === 0 || i === 100) {
                    ctx.textAlign = 'right';
                    ctx.fillText(i, axisX - 10, yPos + 4);
                }
            }
            

        }
        
        // Draw 5 elements
        function drawElements() {
            // Draw watermarks (original positions) first
            originalPositions.forEach((orig) => {
                const pixelX = originX + orig.x * scale;
                const pixelY = originY - orig.y * scale;
                
                // Draw faded circle at original position
                ctx.fillStyle = orig.color;
                ctx.globalAlpha = 0.15; // Faded watermark
                ctx.beginPath();
                ctx.arc(pixelX, pixelY, 21, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0; // Reset alpha
            });
            
            // Draw connecting lines first (so they appear behind the points)
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const firstPoint = elements[connectionOrder[0]];
            const firstPixelX = originX + firstPoint.x * scale;
            const firstPixelY = originY - firstPoint.y * scale;
            ctx.moveTo(firstPixelX, firstPixelY);
            
            for (let i = 1; i < connectionOrder.length; i++) {
                const element = elements[connectionOrder[i]];
                const pixelX = originX + element.x * scale;
                const pixelY = originY - element.y * scale;
                ctx.lineTo(pixelX, pixelY);
            }
            ctx.stroke();
            
            // Draw circles for each element
            elements.forEach((element, index) => {
                const pixelX = originX + element.x * scale;
                const pixelY = originY - element.y * scale;
                
                // Draw circle
                ctx.fillStyle = element.color;
                ctx.beginPath();
                ctx.arc(pixelX, pixelY, 21, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw border - thicker if selected
                ctx.strokeStyle = selectedElement === index ? '#000' : '#000';
                ctx.lineWidth = selectedElement === index ? 3 : 1.5;
                ctx.stroke();
                
                // Label - centered on the point
                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(element.name, pixelX, pixelY);
            });
        }
        
        // Click handler
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const pixelX = e.clientX - rect.left;
            const pixelY = e.clientY - rect.top;
            
            // Check if clicked on any element
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                const elementPixelX = originX + element.x * scale;
                const elementPixelY = originY - element.y * scale;
                
                const distance = Math.sqrt(
                    Math.pow(pixelX - elementPixelX, 2) + Math.pow(pixelY - elementPixelY, 2)
                );
                
                if (distance <= 21) {
                    selectedElement = i;
                    updateSelectedPanel();
                    draw();
                    return;
                }
            }
            
            // Deselect if clicked elsewhere
            selectedElement = null;
            document.getElementById('selectedPanel').classList.remove('active');
            draw();
        });
        
        // Update selected panel display
        function updateSelectedPanel() {
            const panel = document.getElementById('selectedPanel');
            if (selectedElement !== null) {
                const element = elements[selectedElement];
                document.getElementById('selectedInfo').textContent = `Selected: ${element.name}`;
                document.getElementById('xValue').textContent = element.x;
                document.getElementById('yValue').textContent = element.y;
                panel.classList.add('active');
            }
        }
        
        // Randomize elements while maintaining total values
        function randomizeElements() {
            const totalX = 250;
            const totalY = 251;
            
            let validConfig = false;
            
            while (!validConfig) {
                validConfig = true;
                let sumX = 0;
                let sumY = 0;
                
                // Generate random values for first 4 elements (1-99)
                for (let i = 0; i < 4; i++) {
                    elements[i].x = Math.round((Math.random() * 98 + 1) * 1000) / 1000; // Random 1-99
                    elements[i].y = Math.round((Math.random() * 98 + 1) * 1000) / 1000;
                    sumX += elements[i].x;
                    sumY += elements[i].y;
                }
                
                // Calculate 5th element to maintain totals
                elements[4].x = Math.round((totalX - sumX) * 1000) / 1000;
                elements[4].y = Math.round((totalY - sumY) * 1000) / 1000;
                
                // Validate that 5th element is within 1-99
                if (elements[4].x < 1 || elements[4].x > 99 || elements[4].y < 1 || elements[4].y > 99) {
                    validConfig = false; // Regenerate if out of range
                }
            }
            
            // Deselect element and update display
            selectedElement = null;
            document.getElementById('selectedPanel').classList.remove('active');
            draw();
        }
        
        // Change X value (YIN) with cascading effect
        function changeX(delta) {
            if (selectedElement !== null) {
                if (delta > 0) {
                    // Increase: add 1 unit at a time, cascading backwards through 4 elements
                    for (let addCount = 0; addCount < delta; addCount++) {
                        // Add 1 to selected element (clamp to max 99)
                        elements[selectedElement].x = Math.min(99, Math.round((elements[selectedElement].x + 1) * 1000) / 1000);
                        
                        // Cascade 1 unit backwards through 4 elements
                        let amountToReduce = 1;
                        let currentElement = (selectedElement - 1 + 5) % 5;
                        
                        for (let i = 0; i < 4; i++) {
                            const reduction = amountToReduce * 0.5;
                            elements[currentElement].x = Math.max(1, Math.round((elements[currentElement].x - reduction) * 1000) / 1000);
                            amountToReduce = reduction;
                            currentElement = (currentElement - 1 + 5) % 5;
                        }
                    }
                } else if (delta < 0) {
                    // Decrease: distribute to next elements with 50% cascading
                    const totalToDistribute = -delta;
                    
                    if (elements[selectedElement].x >= totalToDistribute) {
                        elements[selectedElement].x = Math.max(1, Math.round((elements[selectedElement].x - totalToDistribute) * 1000) / 1000);
                        
                        let amountPassing = totalToDistribute;
                        for (let i = 0; i < 4; i++) {
                            const targetElement = (selectedElement + i + 1) % 5;
                            const amountToKeep = Math.round(amountPassing * 500) / 1000; // 50% to 3 decimals
                            
                            elements[targetElement].x = Math.min(99, Math.round((elements[targetElement].x + amountToKeep) * 1000) / 1000);
                            amountPassing = Math.round((amountPassing - amountToKeep) * 1000) / 1000;
                        }
                    }
                }
                updateSelectedPanel();
                draw();
            }
        }
        
        // Change Y value (YANG) with cascading effect
        function changeY(delta) {
            if (selectedElement !== null) {
                if (delta > 0) {
                    // Increase: add 1 unit at a time, cascading backwards through 4 elements
                    for (let addCount = 0; addCount < delta; addCount++) {
                        // Add 1 to selected element (clamp to max 99)
                        elements[selectedElement].y = Math.min(99, Math.round((elements[selectedElement].y + 1) * 1000) / 1000);
                        
                        // Cascade 1 unit backwards through 4 elements
                        let amountToReduce = 1;
                        let currentElement = (selectedElement - 1 + 5) % 5;
                        
                        for (let i = 0; i < 4; i++) {
                            const reduction = amountToReduce * 0.5;
                            elements[currentElement].y = Math.max(1, Math.round((elements[currentElement].y - reduction) * 1000) / 1000);
                            amountToReduce = reduction;
                            currentElement = (currentElement - 1 + 5) % 5;
                        }
                    }
                } else if (delta < 0) {
                    // Decrease: distribute to next elements with 50% cascading
                    const totalToDistribute = -delta;
                    
                    if (elements[selectedElement].y >= totalToDistribute) {
                        elements[selectedElement].y = Math.max(1, Math.round((elements[selectedElement].y - totalToDistribute) * 1000) / 1000);
                        
                        let amountPassing = totalToDistribute;
                        for (let i = 0; i < 4; i++) {
                            const targetElement = (selectedElement + i + 1) % 5;
                            const amountToKeep = Math.round(amountPassing * 500) / 1000; // 50% to 3 decimals
                            
                            elements[targetElement].y = Math.min(99, Math.round((elements[targetElement].y + amountToKeep) * 1000) / 1000);
                            amountPassing = Math.round((amountPassing - amountToKeep) * 1000) / 1000;
                        }
                    }
                }
                updateSelectedPanel();
                draw();
            }
        }
        
        // Redraw everything
        function draw() {
            drawAxis();
            drawElements();
        }
        
        // Initial draw when page loads
        window.addEventListener('load', () => {
            draw();
        });
    </script>
</body>
</html>
